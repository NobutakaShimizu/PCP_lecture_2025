\chapter{導入}

この集中講義ではPCP定理と呼ばれる計算量理論の基本的な結果について解説し, その証明を与える.
PCP定理は1998年に\citet{AroraS98,AroraLMSS98}によって証明された.
この証明は代数的な手法に基づく誤り訂正符号を技巧的に組合せたものであり, 難解なものであったが, その後\citet{Din07}によってより簡潔な証明が与えられた.
この講義では\citet{Din07}による比較的簡単な証明を紹介する.
ちなみにDinurはのちにこの業績によりゲーデル賞を受賞している.

\section{計算量理論の復習}
まずは計算量理論のどの教科書にも載っているような基礎的な用語の定義を与える.
なお, このノートではアルゴリズムの定義 (チューリング機械の定義) は省略し, アルゴリズムについて述べる際は具体的な計算の手続きを述べる\footnote{ひとまずPythonやC言語などで実装されたプログラムを考えれば良い. ただし, 計算機内では全ての数値は有限桁の二進数で表記されており, その読み書きや演算には少なくとも桁数に比例した計算時間がかかる. なお, $\sqrt{2}$といった無理数は本来は有限桁で打ち切った近似値を扱うが, そのような小数はこの講義では扱わず, 特に断りのない限りは整数値のみを考える.}.

まずは基本的な記号の定義を与える:
\begin{itemize}
\item 自然数$n\in\Nat$に対して$[n]=\qty{1,\dots,n}$とする.
\item $\binset^*=\bigcup_{n\in\Nat}\binset^n$を有限長の二進文字列全体とする.
\item $x\in\binset^*$に対して$\abs{x}$を$x$の文字数とする.
\item アルゴリズム$A$に対し, $A(x)$を入力$x \in \binset^*$に対するアルゴリズム$A$の出力とする. ここで, 単に「アルゴリズム」と言った場合は決定的アルゴリズムを指し, 乱択アルゴリズムについては明示的に言及する.
\item 関数$T(n)\colon\Nat\to\Nat$を考える. 十分大きな全ての$n\in\Nat$と全ての$x\in\binset^n$に対して, $A$が$A(x)$を出力するまでにかかる計算ステップ数の最大値が高々$T(n)$であるとき, アルゴリズム$A$の計算量は$T(n)$であるという.
\end{itemize}

PCP定理では主に判定問題と呼ばれる次のような問題を考える:

\begin{definition}{判定問題}{decision-problem}
  部分集合$L\subseteq\binset^*$を\emph{判定問題(または言語)}という.
  また, 文字列$x\in\binset^*$は$x\in L$であるとき, 判定問題$L$の\emph{Yesインスタンス}といい,
  そうでない場合は\emph{Noインスタンス}という.

  文字列$x\in\binset^*$に対し$L(x)\in\binset$を, $x\in L$かどうかの指示関数, すなわち$x\in L$ならば$L(x)=1$, そうでなければ$L(x)=0$と定義する.
\end{definition}

次に乱択アルゴリズムについて定義する. 端的に言えばアルゴリズムの内部でコイントスを行うものを乱択アルゴリズムという.
ここでは明示的にランダムシードを受け取るアルゴリズムを乱択アルゴリズムと呼ぶことにする.

\begin{definition}{乱択アルゴリズム}{randomized-algorithm}
  アルゴリズム$A(x;r)$は, 入力$x\in\binset^*$とは別にランダムシードと呼ばれる別の文字列$r\in\binset^*$を受け取るとき, \emph{乱択アルゴリズム}という.
  なお, 任意の$x,r\in\binset^*$に対して$A(x;r)$は有限時間で停止するとし, その計算量は$\abs{x}$のみに依存する関数で表せるとする.
  このとき, ランダムシード$r$の長さを常に$A$の計算量で上から抑える.
  すなわち, $A$の計算量が$T(n)$であるとき, 十分大きな全ての$n\in\Nat$と全ての$x\in\binset^n$に対して$A$が読み込む$r$の文字数は高々$T(n)$であるため, $r\in \binset^{T(n)}$であると仮定する.

  乱択アルゴリズムのランダムシードに関する確率, 期待値, 分散を議論する際は記号として$\Pr_{A}[\cdot],\E_A[\cdot],\Var_A[\cdot]$を用いる.
  乱択アルゴリズム$A$が判定問題$L$を解くとは,
  \begin{align*}
    \Pr_A[A(x;r)=L(x)]\geq 2/3
  \end{align*}
  が成り立つことをいう.
\end{definition}

また, 入力とは別に文字列へのオラクルアクセスを受け取るアルゴリズムを考える.
\begin{definition}{オラクルアルゴリズム}{oracle-algorithm}
  文字列$\pi\in\binset^*$に対し, $\pi$への\emph{オラクルアクセス}を持つアルゴリズム$A^\pi(x)$とは, 計算途中で$\pi$の指定された位置の文字を読むことができるアルゴリズムである.
  すなわち, $\pi$の$i$番目の文字を読む操作を$A^\pi(x)$の計算過程中に$O(\log \abs{\pi})$時間で行うことができるアルゴリズムである.\footnote{自然数$i\in[\abs{\pi}]$を指定するために$O(\log \abs{\pi})$ビットを定めなければならないため, $O(\log i)$時間を仮定している.}
  同様に乱択オラクルアルゴリズムについても定義できる.
\end{definition}


\section{検証の計算量}
このノートでは主に検証の計算量について考える.
検証とは, ある命題が真であると主張する証明が文字列として与えられたとき, その証明が実際に
その命題を正しく証明しているかどうかを判定する問題である.
数学の証明の査読業務をイメージしてもらうとわかりやすいだろう.
ただしここで扱う「命題」とは, 一般の数学の命題ではなく, 例えば「特定のグラフ$G$は3彩色を持つ」「線形方程式系$Ax=b$は解を持つ」といった, 具体的な問題例を考える.

フォーマルに議論するため, 検証の概念を導入する.

例えば, グラフ$G$が3彩色を持つかどうかという問題は, 3彩色問題と呼ばれる判定問題であり,
判定問題$f\colon\binset^*\to\binset$を考える.\footnote{$\binset^*=\bigcup_{n\in\Nat}\binset^n$は有限長の二進文字列全体. 判定問題とは, 文字列が与えられたときにYesまたはNoを答える問題である.}
検証では\emph{検証者(verifier)}と呼ばれるアルゴリズム$\Ver(x)$を考える.
このアルゴリズムは入力として

\subsection{効率的な検証とクラスNP}
\subsection{確率的な検証とクラスMA}
\subsection{局所的な検証とクラスPCP}

\section{PCP定理}

\subsection{自明な例}

\begin{theorem}{PCP定理}{PCPtheorem}
  ...
\end{theorem}
